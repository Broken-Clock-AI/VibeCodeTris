{"version":3,"file":"worker-aGWtwGGP.js","sources":["../src/logic/constants.ts","../src/logic/rng.ts","../src/logic/rules.ts","../src/logic/recover.ts","../src/logic/engine.ts","../src/logic/worker.ts"],"sourcesContent":["// src/logic/constants.ts\n\n// --- Core Gameplay ---\nexport const COLS = 10;\nexport const ROWS = 20;\nexport const TICK_MS = 1000 / 60; // 60 ticks per second\n\n// --- Timing (in Ticks) ---\nexport const DAS = 10; // Delayed Auto Shift\nexport const ARR = 2;  // Auto Repeat Rate\nexport const LOCK_DELAY = 30; // Ticks before a piece locks down\nexport const GRAVITY_START_DELAY = 60; // Ticks before gravity starts\n\n// --- Versioning ---\nexport const PROTOCOL_VERSION = 1;\nexport const CURRENT_ENGINE_VERSION = \"0.1.0\";\nexport const SNAPSHOT_SCHEMA_VERSION = 1;\n","/**\n * A simple, seedable pseudo-random number generator (PRNG).\n * This uses the Mulberry32 algorithm, which is fast, simple, and produces high-quality 32-bit integers.\n * Its state is a single 32-bit integer, making it easy to serialize and deserialize for replays.\n */\nexport class PRNG {\n  private state: number;\n\n  /**\n   * Creates a new PRNG instance.\n   * @param seed The initial seed value.\n   */\n  constructor(seed: number) {\n    this.state = seed;\n  }\n\n  /**\n   * Returns the next pseudo-random 32-bit integer in the sequence.\n   * This is the core of the Mulberry32 algorithm.\n   */\n  public nextInt(): number {\n    let z = (this.state += 0x6d2b79f5);\n    z = (z ^ (z >>> 15)) * (z | 1);\n    z ^= z + (z ^ (z >>> 7)) * (z | 61);\n    return (z ^ (z >>> 14)) >>> 0;\n  }\n\n  /**\n   * Returns the next pseudo-random floating-point number between 0 (inclusive) and 1 (exclusive).\n   * This is useful for tasks like shuffling.\n   */\n  public nextFloat(): number {\n    return this.nextInt() / 4294967296;\n  }\n\n  /**\n   * Returns the current state of the generator.\n   * This is essential for saving the game state for replays or recovery.\n   */\n  public getState(): number {\n    return this.state;\n  }\n\n  /**\n   * Sets the current state of the generator.\n   * This is essential for restoring the game state for replays or recovery.\n   * @param state The state to restore.\n   */\n  public setState(state: number): void {\n    this.state = state;\n  }\n}\n","// src/logic/rules.ts\n\nimport { COLS, ROWS } from './constants';\nimport { Snapshot } from './types';\n\n// --- SRS (Super Rotation System) Data ---\n\n// Piece shapes for I, J, L, O, S, T, Z\nconst PIECE_SHAPES = {\n  I: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],\n  J: [[1, 0, 0], [1, 1, 1], [0, 0, 0]],\n  L: [[0, 0, 1], [1, 1, 1], [0, 0, 0]],\n  O: [[1, 1], [1, 1]],\n  S: [[0, 1, 1], [1, 1, 0], [0, 0, 0]],\n  T: [[0, 1, 0], [1, 1, 1], [0, 0, 0]],\n  Z: [[1, 1, 0], [0, 1, 1], [0, 0, 0]],\n};\n\n// Wall kick data for J, L, S, T, Z pieces\nconst WALL_KICK_DATA_JLSTZ = [\n  [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]], // 0 -> 1\n  [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],   // 1 -> 0\n  [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],   // 1 -> 2\n  [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]], // 2 -> 1\n  [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],   // 2 -> 3\n  [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]], // 3 -> 2\n  [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]], // 3 -> 0\n  [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],   // 0 -> 3\n];\n\n// Wall kick data for I piece\nconst WALL_KICK_DATA_I = [\n    [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]],  // 0 -> 1\n    [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]],   // 1 -> 0\n    [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]],  // 1 -> 2\n    [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]],   // 2 -> 1\n    [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]],  // 2 -> 3\n    [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]],   // 3 -> 2\n    [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]],   // 3 -> 0\n    [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]],  // 0 -> 3\n];\n\n\n// --- Pure Game Logic Functions ---\n\n/**\n * Checks if a piece at a given position is valid (not colliding with walls or other blocks).\n * @param matrix The piece's current rotation matrix.\n * @param x The x-coordinate of the piece.\n * @param y The y-coordinate of the piece.\n * @param board The game board state.\n * @returns True if the position is valid, false otherwise.\n */\nexport function isValidPosition(matrix: number[][], x: number, y: number, board: Uint8Array): boolean {\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      if (matrix[row][col]) {\n        const boardX = x + col;\n        const boardY = y + row;\n\n        // Check bounds first\n        if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {\n          return false;\n        }\n\n        // Then check for collision with existing pieces, but only for valid board coordinates\n        if (boardY >= 0 && board[boardY * COLS + boardX]) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Rotates a piece's matrix.\n * @param matrix The matrix to rotate.\n * @param direction 1 for clockwise, -1 for counter-clockwise.\n * @returns The new rotated matrix.\n */\nexport function rotateMatrix(matrix: number[][], direction: number): number[][] {\n    const N = matrix.length;\n    const result = Array.from({ length: N }, () => Array(N).fill(0));\n\n    for (let r = 0; r < N; r++) {\n        for (let c = 0; c < N; c++) {\n            if (direction === 1) { // Clockwise\n                result[c][N - 1 - r] = matrix[r][c];\n            } else { // Counter-clockwise\n                result[N - 1 - c][r] = matrix[r][c];\n            }\n        }\n    }\n    return result;\n}\n\n/**\n * Calculates the score for a given move.\n * @param linesCleared The number of lines cleared.\n * @param level The current game level.\n * @param isTSpin Whether the move was a T-Spin.\n * @param isBackToBack Whether the move qualifies for a back-to-back bonus.\n * @returns The score awarded for the move.\n */\nexport function calculateScore(\n    linesCleared: number,\n    level: number,\n    isTSpin: boolean = false,\n    isBackToBack: boolean = false\n): number {\n    let baseScore = 0;\n\n    if (isTSpin) {\n        switch (linesCleared) {\n            case 0: baseScore = 400; break; // T-Spin Mini\n            case 1: baseScore = 800; break; // T-Spin Single\n            case 2: baseScore = 1200; break; // T-Spin Double\n            case 3: baseScore = 1600; break; // T-Spin Triple\n        }\n    } else {\n        switch (linesCleared) {\n            case 1: baseScore = 100; break; // Single\n            case 2: baseScore = 300; break; // Double\n            case 3: baseScore = 500; break; // Triple\n            case 4: baseScore = 800; break; // Tetris\n        }\n    }\n\n    let score = baseScore * level;\n\n    if (isBackToBack && (linesCleared === 4 || isTSpin)) {\n        score *= 1.5;\n    }\n\n    return Math.floor(score);\n}","// src/logic/recover.ts\nimport { CURRENT_ENGINE_VERSION, PROTOCOL_VERSION, SNAPSHOT_SCHEMA_VERSION } from './constants';\nimport { Snapshot } from './types';\n\n/**\n * This file contains the logic for snapshot validation and recovery.\n */\n\n/**\n * Calculates a simple checksum for a snapshot object.\n * In a real-world scenario, a more robust hashing algorithm like xxhash32 would be used.\n * @param snapshot The snapshot to hash.\n * @returns A numeric checksum.\n */\nexport function calculateChecksum(snapshot: Omit<Snapshot, 'checksum'>): number {\n    // This is a placeholder. A real implementation would use a fast hashing algorithm.\n    // For now, we'll just use a simple string-based hash.\n    const snapshotString = JSON.stringify({ ...snapshot, checksum: undefined });\n    let hash = 0;\n    for (let i = 0; i < snapshotString.length; i++) {\n        const char = snapshotString.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash |= 0; // Convert to 32bit integer\n    }\n    return hash;\n}\n\n\n/**\n * Validates a snapshot to ensure it's safe to use for recovery.\n * @param snapshot The snapshot to validate.\n * @returns True if the snapshot is valid, false otherwise.\n */\nexport function validateSnapshot(snapshot: Snapshot): boolean {\n    if (!snapshot) {\n        console.error(\"Validation failed: Snapshot is null or undefined.\");\n        return false;\n    }\n\n    // 1. Check versions\n    if (snapshot.protocolVersion !== PROTOCOL_VERSION) {\n        console.error(`Validation failed: Protocol version mismatch. Expected ${PROTOCOL_VERSION}, got ${snapshot.protocolVersion}`);\n        return false;\n    }\n    if (snapshot.engineVersion !== CURRENT_ENGINE_VERSION) {\n        console.warn(`Validation warning: Engine version mismatch. Expected ${CURRENT_ENGINE_VERSION}, got ${snapshot.engineVersion}`);\n        // This might be a warning rather than a fatal error in some strategies.\n    }\n    if (snapshot.snapshotSchemaVersion !== SNAPSHOT_SCHEMA_VERSION) {\n        console.error(`Validation failed: Snapshot schema mismatch. Expected ${SNAPSHOT_SCHEMA_VERSION}, got ${snapshot.snapshotSchemaVersion}`);\n        return false;\n    }\n\n    // 2. Verify the checksum\n    // We need to calculate the checksum on a snapshot object with the checksum field removed.\n    const { checksum, ...snapshotData } = snapshot;\n    const expectedChecksum = calculateChecksum(snapshotData);\n\n    if (checksum !== expectedChecksum) {\n        console.error(`Validation failed: Checksum mismatch. Expected ${expectedChecksum}, got ${checksum}`);\n        // In a real app, you'd likely want to fail here. For now, we can log it.\n        // return false; \n    }\n\n    // 3. Ensure board dimensions and other fields are within sane limits.\n    if (snapshot.rows <= 0 || snapshot.cols <= 0 || snapshot.boardBuffer.byteLength !== snapshot.rows * snapshot.cols) {\n        console.error(\"Validation failed: Invalid board dimensions.\");\n        return false;\n    }\n    \n    if (snapshot.tick < 0 || snapshot.snapshotId < 0) {\n        console.error(\"Validation failed: Invalid tick or snapshot ID.\");\n        return false;\n    }\n\n    console.log(`Snapshot ${snapshot.snapshotId} passed validation.`);\n    return true;\n}\n","import { COLS, DAS, GRAVITY_START_DELAY, LOCK_DELAY, ROWS, CURRENT_ENGINE_VERSION, PROTOCOL_VERSION, SNAPSHOT_SCHEMA_VERSION, ARR } from './constants';\nimport { PRNG } from './rng';\nimport { calculateScore, isValidPosition, rotateMatrix } from './rules';\nimport { GameEvent, Snapshot } from './types';\nimport { calculateChecksum } from './recover';\n\n// --- Piece Definitions ---\nconst PIECE_TYPES = 'IJLOSTZ';\nconst PIECE_SHAPES = {\n  I: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],\n  J: [[1, 0, 0], [1, 1, 1], [0, 0, 0]],\n  L: [[0, 0, 1], [1, 1, 1], [0, 0, 0]],\n  O: [[1, 1], [1, 1]],\n  S: [[0, 1, 1], [1, 1, 0], [0, 0, 0]],\n  T: [[0, 1, 0], [1, 1, 1], [0, 0, 0]],\n  Z: [[1, 1, 0], [0, 1, 1], [0, 0, 0]],\n};\n\n\nexport class TetrisEngine {\n  // --- Core State ---\n  private prng: PRNG;\n  private board: Uint8Array;\n  private tickCounter: number;\n\n  // --- Piece and Bag State ---\n  private bag: string[];\n  private currentPiece: { type: string; matrix: number[][]; x: number; y: number; rotation: number; colorIndex: number; } | null;\n  private holdType: number;\n  private nextTypes: Uint8Array;\n\n  // --- Timing and Input State ---\n  private lockCounter: number;\n  private gravityCounter: number;\n  private das: number;\n  private arr: number;\n  private dasCounter: { left: number; right: number; down: number };\n  private isMoving: { left: boolean; right: boolean; down: boolean };\n  \n  // --- Gameplay State ---\n  private score: number;\n  private level: number;\n  private lines: number;\n  private backToBack: number;\n  private combo: number;\n  private gameOver: boolean;\n  \n  // --- Ephemeral State ---\n  private events: GameEvent[];\n\n  constructor(seed: number) {\n    this.prng = new PRNG(seed);\n    this.board = new Uint8Array(ROWS * COLS).fill(0);\n    this.tickCounter = 0;\n    \n    this.bag = [];\n    this.nextTypes = new Uint8Array(6); // Show 6 next pieces\n    this.fillBag(); // Initial fill\n    this.fillBag(); // Fill again to populate `nextTypes`\n    \n    this.currentPiece = null;\n    this.holdType = 0;\n\n    this.lockCounter = 0;\n    this.gravityCounter = 0;\n    this.das = DAS;\n    this.arr = ARR;\n    this.dasCounter = { left: 0, right: 0, down: 0 };\n    this.isMoving = { left: false, right: false, down: false };\n\n    this.score = 0;\n    this.level = 1;\n    this.lines = 0;\n    this.backToBack = 0;\n    this.combo = 0;\n    this.gameOver = false;\n\n    this.events = [];\n  }\n\n  /**\n   * Creates a new TetrisEngine instance from a snapshot.\n   * @param snapshot The snapshot to restore from.\n   * @returns A new TetrisEngine instance.\n   */\n  public static fromSnapshot(snapshot: Snapshot): TetrisEngine {\n    // Note: We pass a dummy seed to the constructor because we're about to overwrite everything.\n    const engine = new TetrisEngine(1);\n\n    engine.tickCounter = snapshot.tick;\n    engine.prng = new PRNG(snapshot.prngState[0]);\n    \n    engine.board = new Uint8Array(snapshot.boardBuffer);\n    \n    engine.bag = Array.from(snapshot.bagState.bag).map(typeId => PIECE_TYPES[typeId - 1]);\n    engine.nextTypes = snapshot.nextTypes;\n    engine.holdType = snapshot.holdType;\n\n    if (snapshot.current) {\n        const shape = PIECE_SHAPES[snapshot.current.type as keyof typeof PIECE_SHAPES];\n        const matrix = [];\n        for (let i = 0; i < shape.length; i++) {\n            matrix.push(Array.from(snapshot.current.matrix.slice(i * shape[0].length, (i + 1) * shape[0].length)));\n        }\n        engine.currentPiece = {\n            ...snapshot.current,\n            matrix: matrix,\n        };\n    } else {\n        engine.currentPiece = null;\n    }\n\n    engine.lockCounter = snapshot.lockCounter;\n    engine.gravityCounter = snapshot.gravityCounter;\n    engine.score = snapshot.score;\n    engine.level = snapshot.level;\n    engine.lines = snapshot.lines;\n    engine.backToBack = snapshot.backToBack;\n    engine.combo = snapshot.combo;\n    \n    engine.events = []; // Events are ephemeral and not restored\n\n    return engine;\n  }\n\n  /**\n   * Updates the engine's timing values.\n   * @param das The new Delayed Auto Shift value.\n   * @param arr The new Auto Repeat Rate value.\n   */\n  public setTimings(das: number, arr: number): void {\n    this.das = das;\n    this.arr = arr;\n  }\n\n  /**\n   * The main deterministic game loop.\n   */\n  public tick(): Snapshot {\n    if (this.gameOver) {\n        return this.createSnapshot();\n    }\n    this.tickCounter++;\n    this.events = []; // Clear events for the new tick\n\n    if (!this.currentPiece) {\n        this.spawnPiece();\n    }\n\n    // --- Handle continuous movement (DAS/ARR) ---\n    this.updateMovement();\n\n    // --- Gravity ---\n    if (this.currentPiece) {\n        this.gravityCounter++;\n        // TODO: Replace with dynamic gravity based on level\n        const currentGravity = GRAVITY_START_DELAY; \n\n        if (this.gravityCounter >= currentGravity) {\n            this.gravityCounter = 0;\n            \n            const newY = this.currentPiece.y + 1;\n            if (isValidPosition(this.currentPiece.matrix, this.currentPiece.x, newY, this.board)) {\n                this.currentPiece.y = newY;\n            } else {\n                // Piece has landed, handle locking\n                this.lockPiece();\n            }\n        }\n    }\n    \n    // ... game logic will go here ...\n\n    return this.createSnapshot();\n  }\n\n  /**\n   * Processes a user input action.\n   * @param action The input action to process (e.g., 'moveLeft', 'rotateCW').\n   */\n  public handleInput(action: string): void {\n    if (!this.currentPiece || this.gameOver) return;\n\n    let { x, y, matrix } = this.currentPiece;\n\n    switch (action) {\n        case 'moveLeft':\n            this.isMoving.left = true;\n            this.dasCounter.left = 0;\n            x--;\n            break;\n        case 'moveLeft_release':\n            this.isMoving.left = false;\n            break;\n        case 'moveRight':\n            this.isMoving.right = true;\n            this.dasCounter.right = 0;\n            x++;\n            break;\n        case 'moveRight_release':\n            this.isMoving.right = false;\n            break;\n        case 'softDrop':\n            this.isMoving.down = true;\n            this.dasCounter.down = 0;\n            y++;\n            break;\n        case 'softDrop_release':\n            this.isMoving.down = false;\n            break;\n        case 'hardDrop':\n            // This will be handled by finding the final position and locking instantly\n            while (isValidPosition(matrix, x, y + 1, this.board)) {\n                y++;\n            }\n            this.currentPiece.y = y;\n            this.lockPiece();\n            return; // Exit early as lockPiece is called\n        case 'rotateCW':\n            matrix = rotateMatrix(matrix, 1);\n            // TODO: Add wall kick logic here\n            break;\n        case 'rotateCCW':\n            matrix = rotateMatrix(matrix, -1);\n            // TODO: Add wall kick logic here\n            break;\n        case 'hold':\n            // TODO: Implement hold logic\n            break;\n    }\n\n    if (isValidPosition(matrix, x, y, this.board)) {\n        this.currentPiece.x = x;\n        this.currentPiece.y = y;\n        this.currentPiece.matrix = matrix;\n    }\n  }\n\n  /**\n   * Handles the continuous movement logic for DAS and ARR.\n   */\n  private updateMovement(): void {\n    if (!this.currentPiece) return;\n\n    // --- Left Movement ---\n    if (this.isMoving.left) {\n        this.dasCounter.left++;\n        if (this.dasCounter.left > this.das) {\n            if ((this.dasCounter.left - this.das) % this.arr === 0) {\n                if (isValidPosition(this.currentPiece.matrix, this.currentPiece.x - 1, this.currentPiece.y, this.board)) {\n                    this.currentPiece.x--;\n                }\n            }\n        }\n    }\n\n    // --- Right Movement ---\n    if (this.isMoving.right) {\n        this.dasCounter.right++;\n        if (this.dasCounter.right > this.das) {\n            if ((this.dasCounter.right - this.das) % this.arr === 0) {\n                if (isValidPosition(this.currentPiece.matrix, this.currentPiece.x + 1, this.currentPiece.y, this.board)) {\n                    this.currentPiece.x++;\n                }\n            }\n        }\n    }\n\n    // --- Soft Drop Movement ---\n    if (this.isMoving.down) {\n        this.dasCounter.down++;\n        if (this.dasCounter.down > this.das) {\n            if ((this.dasCounter.down - this.das) % this.arr === 0) {\n                if (isValidPosition(this.currentPiece.matrix, this.currentPiece.x, this.currentPiece.y + 1, this.board)) {\n                    this.currentPiece.y++;\n                }\n            }\n        }\n    }\n  }\n\n  /**\n   * Locks the current piece to the board and spawns a new one.\n   */\n  private lockPiece(): void {\n    if (!this.currentPiece) return;\n\n    // Add piece to board\n    for (let r = 0; r < this.currentPiece.matrix.length; r++) {\n        for (let c = 0; c < this.currentPiece.matrix[r].length; c++) {\n            if (this.currentPiece.matrix[r][c]) {\n                const boardX = this.currentPiece.x + c;\n                const boardY = this.currentPiece.y + r;\n                // Game Over Check: Piece locked above the visible board\n                if (boardY < 0) {\n                    this.gameOver = true;\n                    this.events.push({ type: 'gameOver', tick: this.tickCounter });\n                    this.currentPiece = null;\n                    return; // End the lock process immediately\n                }\n                this.board[boardY * COLS + boardX] = PIECE_TYPES.indexOf(this.currentPiece.type) + 1;\n            }\n        }\n    }\n\n    // --- Line Clearing & Scoring ---\n    let linesCleared = 0;\n    const clearedRows: number[] = [];\n    for (let r = ROWS - 1; r >= 0; r--) {\n        const isLineFull = ![...this.board.slice(r * COLS, (r + 1) * COLS)].includes(0);\n        if (isLineFull) {\n            linesCleared++;\n            clearedRows.push(r);\n            // Shift all rows above down\n            for (let y = r; y > 0; y--) {\n                for (let x = 0; x < COLS; x++) {\n                    this.board[y * COLS + x] = this.board[(y - 1) * COLS + x];\n                }\n            }\n            // Clear the top row\n            for (let x = 0; x < COLS; x++) {\n                this.board[x] = 0;\n            }\n            // Since we shifted down, we need to check the same row again\n            r++; \n        }\n    }\n\n    if (linesCleared > 0) {\n        this.combo++;\n        // TODO: T-Spin detection\n        const isTSpin = false; \n        const isBackToBack = this.backToBack > 0 && (linesCleared === 4 || isTSpin);\n        \n        const scoreGained = calculateScore(linesCleared, this.level, isTSpin, isBackToBack);\n        this.score += scoreGained;\n        this.lines += linesCleared;\n        this.level = Math.floor(this.lines / 10) + 1;\n\n        this.events.push({ type: 'lineClear', tick: this.tickCounter, data: { rows: clearedRows, count: linesCleared } });\n        this.events.push({ type: 'scoreUpdate', tick: this.tickCounter, data: { score: this.score, lines: this.lines, level: this.level } });\n\n        if (linesCleared === 4 || isTSpin) {\n            this.backToBack++;\n        } else {\n            this.backToBack = 0;\n        }\n    } else {\n        this.combo = 0;\n    }\n\n    // Reset for next piece\n    this.currentPiece = null;\n    this.lockCounter = 0;\n    this.spawnPiece();\n  }\n\n  /**\n   * Fills the piece bag with a new shuffled set of 7 pieces.\n   */\n  private fillBag(): void {\n    const pieces = [...PIECE_TYPES];\n    // Fisher-Yates shuffle\n    for (let i = pieces.length - 1; i > 0; i--) {\n      const j = Math.floor(this.prng.nextFloat() * (i + 1));\n      [pieces[i], pieces[j]] = [pieces[j], pieces[i]];\n    }\n    this.bag.push(...pieces);\n    this.updateNextTypes();\n  }\n\n  /**\n   * Updates the public-facing `nextTypes` array.\n   */\n  private updateNextTypes(): void {\n    for (let i = 0; i < this.nextTypes.length; i++) {\n        this.nextTypes[i] = PIECE_TYPES.indexOf(this.bag[i]) + 1;\n    }\n  }\n\n  /**\n   * Spawns a new piece from the bag.\n   */\n  private spawnPiece(): void {\n    if (this.bag.length <= 7) {\n        this.fillBag();\n    }\n    const type = this.bag.shift()!;\n    this.updateNextTypes();\n\n    const matrix = PIECE_SHAPES[type as keyof typeof PIECE_SHAPES];\n    const colorIndex = PIECE_TYPES.indexOf(type) + 1;\n    \n    this.currentPiece = {\n        type,\n        matrix,\n        x: Math.floor(COLS / 2) - Math.ceil(matrix[0].length / 2),\n        y: 0,\n        rotation: 0,\n        colorIndex,\n    };\n\n    if (!isValidPosition(this.currentPiece.matrix, this.currentPiece.x, this.currentPiece.y, this.board)) {\n        this.gameOver = true;\n        this.events.push({ type: 'gameOver', tick: this.tickCounter });\n        this.currentPiece = null;\n    }\n  }\n\n  /**\n   * Calculates the final Y position of the current piece if it were dropped.\n   * @returns The Y coordinate of the ghost piece's position.\n   */\n  private calculateGhostPosition(): number {\n    if (!this.currentPiece) {\n        return -1; // Should not happen if called correctly\n    }\n    let ghostY = this.currentPiece.y;\n    while (isValidPosition(this.currentPiece.matrix, this.currentPiece.x, ghostY + 1, this.board)) {\n        ghostY++;\n    }\n    return ghostY;\n  }\n\n  /**\n   * Creates a snapshot of the current game state.\n   */\n  private createSnapshot(): Snapshot {\n    const bagUint8 = new Uint8Array(this.bag.length);\n    for (let i = 0; i < this.bag.length; i++) {\n        bagUint8[i] = PIECE_TYPES.indexOf(this.bag[i]) + 1;\n    }\n\n    // Create a single copy of the board buffer to be used for both\n    // the checksum and the transferable payload. The engine's internal\n    // buffer must NOT be transferred.\n    const boardBufferCopy = this.board.buffer.slice(0) as ArrayBuffer;\n\n    const snapshotData: Omit<Snapshot, 'checksum'> = {\n        protocolVersion: PROTOCOL_VERSION,\n        engineVersion: CURRENT_ENGINE_VERSION,\n        snapshotSchemaVersion: SNAPSHOT_SCHEMA_VERSION,\n        snapshotId: this.tickCounter,\n        tick: this.tickCounter,\n        authoritativeTimeMs: this.tickCounter * (1000 / 60), // Assuming 60 TPS for now\n        \n        prngState: new Uint32Array([this.prng.getState()]),\n        bagState: { bag: bagUint8, index: 0 }, // Index is 0 as we shift from the bag\n\n        inputQueueCursor: 0, // Placeholder\n        lockCounter: this.lockCounter,\n        gravityCounter: this.gravityCounter,\n\n        backToBack: this.backToBack,\n        combo: this.combo,\n\n        rows: ROWS,\n        cols: COLS,\n        boardBuffer: boardBufferCopy,\n        \n        current: this.currentPiece ? {\n            ...this.currentPiece,\n            matrix: new Uint8Array(this.currentPiece.matrix.flat()),\n            ghostY: this.calculateGhostPosition(),\n        } : null,\n        \n        nextTypes: this.nextTypes,\n        holdType: this.holdType,\n\n        score: this.score,\n        level: this.level,\n        lines: this.lines,\n        gameOver: this.gameOver,\n\n        events: this.events,\n    };\n\n    const checksum = calculateChecksum(snapshotData);\n    \n    return {\n        ...snapshotData,\n        checksum,\n    };\n  }\n}\n","// src/logic/worker.ts\n\n// --- Environment Agnostic Shim ---\n// This block makes the worker compatible with both browser and Node.js environments.\n// It creates a `self` object that mimics the WorkerGlobalScope for Node.js.\nif (typeof self === 'undefined') {\n    const { parentPort } = require('worker_threads');\n    \n    // Create a `self` object that mimics the properties we need from the browser's WorkerGlobalScope\n    global.self = {\n        postMessage: (message: any, transferables?: Transferable[]) => {\n            parentPort.postMessage(message, transferables);\n        },\n        onmessage: null, // This will be assigned by the worker code later\n    } as any; // Use 'as any' to satisfy TypeScript, as the signatures are not identical\n\n    // When the parent port receives a message, trigger the `self.onmessage` handler\n    parentPort.on('message', (message: any) => {\n        if (global.self.onmessage) {\n            // Simulate the MessageEvent object that the browser would provide\n            global.self.onmessage({ data: message } as MessageEvent);\n        }\n    });\n}\n// --- End Shim ---\n\nimport { TetrisEngine } from './engine';\nimport { TICK_MS } from './constants';\nimport { validateSnapshot } from './recover';\nimport { GameInput, Snapshot } from './types';\n\n// --- Worker State ---\nlet engine: TetrisEngine | null = null;\nlet loop: NodeJS.Timeout | null = null;\nlet sequenceId = 0;\nlet lastReceivedSeq = -1;\nconst inputQueue: GameInput[] = [];\n\nfunction post(type: string, payload?: any, transferables?: Transferable[]) {\n    const message = {\n        protocolVersion: 1,\n        seq: sequenceId++,\n        type,\n        payload,\n    };\n    self.postMessage(message, transferables || []);\n}\n\nfunction stopEngine() {\n    if (loop) {\n        clearInterval(loop);\n        loop = null;\n    }\n    engine = null;\n    inputQueue.length = 0; // Clear the input queue\n    console.log(\"Engine stopped and cleaned up.\");\n}\n\nfunction startEngine(seed: number) {\n    stopEngine(); // Ensure any previous instance is cleared\n    console.log(`Worker starting new engine with seed=${seed}`);\n    engine = new TetrisEngine(seed);\n    loop = setInterval(processTick, TICK_MS);\n    post('log', { level: 'info', msg: 'Engine started.' });\n}\n\nfunction recoverFromSnapshot(snapshot: Snapshot) {\n    if (validateSnapshot(snapshot)) {\n        stopEngine();\n        console.log(`Worker recovering from snapshot ${snapshot.snapshotId}`);\n        engine = TetrisEngine.fromSnapshot(snapshot); \n        \n        loop = setInterval(processTick, TICK_MS);\n        post('log', { level: 'info', msg: `Engine recovered from snapshot ${snapshot.snapshotId}.` });\n    } else {\n        console.error(\"Recovery failed: Received invalid snapshot.\");\n        post('fatal', { error: 'Cannot recover from invalid snapshot.' });\n    }\n}\n\nfunction processTick() {\n    if (!engine) return;\n\n    try {\n        const snapshot = engine.tick();\n        post('snapshot', snapshot, [snapshot.boardBuffer]);\n    } catch (error) {\n        console.error(\"--- FATAL: Engine crashed ---\", error);\n        stopEngine();\n        post('fatal', { error: (error as Error).message });\n    }\n}\n\nfunction handleMessage(data: any) {\n    const { type, payload, seq } = data;\n\n    // --- Sequence Validation ---\n    if (seq !== undefined && seq <= lastReceivedSeq) {\n        console.warn(`Received out-of-order message. Ignoring seq ${seq} (last was ${lastReceivedSeq}).`);\n        post('log', { level: 'warn', msg: `out-of-order` }); // Simplified for test stability\n        return;\n    }\n    if (seq !== undefined) {\n        lastReceivedSeq = seq;\n    }\n\n    switch (type) {\n        case 'start':\n            startEngine(payload.seed);\n            break;\n        \n        case 'input':\n            if (!engine) return;\n            if (typeof payload === 'object' && payload.type === 'setTimings') {\n                engine.setTimings(payload.das, payload.arr);\n            } else {\n                engine.handleInput(payload);\n            }\n            break;\n\n        case 'recover':\n            recoverFromSnapshot(payload);\n            break;\n        \n        case 'requestSnapshot':\n            if (!engine) return;\n            const snapshot = engine.tick();\n            post('snapshot', snapshot, [snapshot.boardBuffer]);\n            break;\n\n        default:\n            console.warn(`Unknown message type received in worker: ${type}`);\n            post('log', { level: 'warn', msg: `Unknown message type: ${type}` });\n            break;\n    }\n}\n\n// --- Attach Message Listener ---\n// @ts-ignore: This is the most reliable way to handle the type mismatch\n// between the browser's MessageEvent and Node's simple message object.\nself.onmessage = (e: any) => {\n    handleMessage(e.data);\n};\n\nconsole.log(\"Worker script loaded and message handler attached.\");"],"names":["TICK_MS","DAS","ARR","GRAVITY_START_DELAY","PROTOCOL_VERSION","CURRENT_ENGINE_VERSION","SNAPSHOT_SCHEMA_VERSION","PRNG","seed","z","state","isValidPosition","matrix","x","y","board","row","col","boardX","boardY","rotateMatrix","direction","N","result","r","c","calculateScore","linesCleared","level","isTSpin","isBackToBack","baseScore","score","calculateChecksum","snapshot","snapshotString","hash","char","validateSnapshot","checksum","snapshotData","expectedChecksum","PIECE_TYPES","PIECE_SHAPES","TetrisEngine","engine","typeId","shape","i","das","arr","currentGravity","newY","action","clearedRows","scoreGained","pieces","j","type","colorIndex","ghostY","bagUint8","boardBufferCopy","parentPort","message","transferables","loop","sequenceId","lastReceivedSeq","post","payload","stopEngine","startEngine","processTick","recoverFromSnapshot","error","handleMessage","data","seq","e"],"mappings":"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"}